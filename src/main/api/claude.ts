import { ipcMain, dialog } from 'electron'
import { promises as fs } from 'fs'
import { join, dirname, basename } from 'path'
import { homedir } from 'os'
import { glob } from 'glob'
import { claudeBinaryManager } from '../detection/ClaudeBinaryManagerAdapter'
import { appSettingsService } from '../database/services'
import { processManager } from '../process/ProcessManager'

/**
 * Gets the actual project path by reading the cwd from the first JSONL entry
 */
async function getProjectPathFromSessions(projectDir: string): Promise<string | null> {
  try {
    const files = await glob(join(projectDir, '*.jsonl').replace(/\\/g, '/'))

    for (const file of files) {
      try {
        const content = await fs.readFile(file, 'utf-8')
        const firstLine = content.split('\n')[0]
        if (firstLine) {
          const json = JSON.parse(firstLine)
          if (json.cwd) {
            return json.cwd
          }
        }
      } catch {
        // Continue to next file
      }
    }
  } catch {
    // Error reading directory
  }

  return null
}

/**
 * Encodes a project path to a directory name compatible with Claude Code
 * This matches Claude Code's encoding logic
 */
export function encodeProjectPath(projectPath: string): string {
  // Replace all non-alphanumeric characters with hyphens
  // This matches Claude Code's behavior
  return projectPath.replace(/[^a-zA-Z0-9]/g, '-')
}

/**
 * Decodes a project directory name back to its original path
 * This is a fallback when we can't get the path from JSONL files
 */
function decodeProjectPath(encoded: string): string {
  // Simple decode - replace hyphens with appropriate path separator
  // Note: This isn't reversible when paths contain hyphens

  // Check if this looks like a Windows path with drive letter (e.g., "C--Users-...")
  if (encoded.match(/^[A-Z]--/)) {
    // Windows path with drive letter
    const driveLetter = encoded.charAt(0)
    const pathPart = encoded.substring(3) // Skip "X--"
    return `${driveLetter}:\\${pathPart.replace(/-/g, '\\')}`
  } else {
    // Unix-like path (macOS/Linux)
    return encoded.replace(/-/g, '/')
  }
}

/**
 * Check if a file exists
 */
async function exists(path: string): Promise<boolean> {
  try {
    await fs.access(path)
    return true
  } catch {
    return false
  }
}

/**
 * Extracts the first valid user message from a JSONL file
 */
async function extractFirstUserMessage(
  jsonlPath: string
): Promise<{ firstMessage: string | null; messageTimestamp: string | null }> {
  try {
    const content = await fs.readFile(jsonlPath, 'utf-8')
    const lines = content.split('\n').filter((line) => line.trim())

    for (const line of lines) {
      try {
        const entry = JSON.parse(line)

        // Check if this is a message entry with user role
        if (entry.message && entry.message.role === 'user' && entry.message.content) {
          const content = entry.message.content

          // Skip if it contains the caveat message
          if (
            content.includes(
              'Caveat: The messages below were generated by the user while running local commands'
            )
          ) {
            continue
          }

          // Skip if it starts with command tags
          if (
            content.startsWith('<command-name>') ||
            content.startsWith('<local-command-stdout>')
          ) {
            continue
          }

          // Found a valid user message
          return {
            firstMessage: content,
            messageTimestamp: entry.timestamp || null
          }
        }
      } catch {
        // Skip invalid JSON lines
      }
    }
  } catch {
    // Error reading file
  }

  return { firstMessage: null, messageTimestamp: null }
}

/**
 * Claude Code related IPC handlers
 */
export function setupClaudeHandlers() {
  // Project Management
  ipcMain.handle('list-projects', async () => {
    console.log('Main: list-projects called')
    try {
      const claudeProjectsDir = join(homedir(), '.claude/projects')

      try {
        await fs.access(claudeProjectsDir)
      } catch {
        // Directory doesn't exist, create it
        await fs.mkdir(claudeProjectsDir, { recursive: true })
        return []
      }

      const entries = await fs.readdir(claudeProjectsDir, { withFileTypes: true })
      const projects: any[] = []

      for (const entry of entries) {
        if (entry.isDirectory()) {
          const projectPath = join(claudeProjectsDir, entry.name)
          const settingsPath = join(projectPath, 'settings.json')

          try {
            // Get the actual project path from JSONL files or fallback to decode
            const actualProjectPath =
              (await getProjectPathFromSessions(projectPath)) || decodeProjectPath(entry.name)

            // Get sessions for this project
            const sessionsPattern = join(projectPath, '*.jsonl')
            const sessionFiles = await glob(sessionsPattern.replace(/\\/g, '/'))
            const sessions = sessionFiles
              .map((file) => basename(file, '.jsonl'))
              .sort()
              .reverse()

            // Get directory stats for created_at
            const stats = await fs.stat(projectPath)
            const created_at = Math.floor((stats.birthtimeMs || stats.ctimeMs) / 1000)

            const settingsContent = await fs.readFile(settingsPath, 'utf-8')
            const settings = JSON.parse(settingsContent)

            projects.push({
              id: entry.name,
              name: settings.name || entry.name,
              path: actualProjectPath,
              sessions,
              created_at,
              settings
            })
          } catch {
            // Settings file doesn't exist or is invalid, use default
            try {
              // Get the actual project path from JSONL files or fallback to decode
              const actualProjectPath =
                (await getProjectPathFromSessions(projectPath)) || decodeProjectPath(entry.name)

              // Try to at least get sessions and stats
              const sessionsPattern = join(projectPath, '*.jsonl')
              const sessionFiles = await glob(sessionsPattern.replace(/\\/g, '/'))
              const sessions = sessionFiles
                .map((file) => basename(file, '.jsonl'))
                .sort()
                .reverse()

              const stats = await fs.stat(projectPath)
              const created_at = Math.floor((stats.birthtimeMs || stats.ctimeMs) / 1000)

              projects.push({
                id: entry.name,
                name: entry.name,
                path: actualProjectPath,
                sessions,
                created_at,
                settings: {}
              })
            } catch {
              // If everything fails, return minimal project info with decoded path
              const actualProjectPath = decodeProjectPath(entry.name)
              projects.push({
                id: entry.name,
                name: entry.name,
                path: actualProjectPath,
                sessions: [],
                created_at: Math.floor(Date.now() / 1000),
                settings: {}
              })
            }
          }
        }
      }

      // Sort projects by created_at in descending order (most recent first)
      return projects.sort((a, b) => b.created_at - a.created_at)
    } catch (error) {
      console.error('Error listing projects:', error)
      return []
    }
  })

  ipcMain.handle('get-project-sessions', async (_, projectId: string) => {
    console.log('Main: get-project-sessions called with', projectId)
    try {
      const claudeProjectsDir = join(homedir(), '.claude/projects')
      const projectPath = join(claudeProjectsDir, projectId)
      const todosDir = join(homedir(), '.claude/todos')

      // Get the actual project path from JSONL files or fallback to decode
      const actualProjectPath =
        (await getProjectPathFromSessions(projectPath)) || decodeProjectPath(projectId)

      // Convert Windows paths to POSIX for glob compatibility
      const sessionsPattern = join(projectPath, '*.jsonl').replace(/\\/g, '/')
      const sessionFiles = await glob(sessionsPattern)

      const sessions: any[] = []
      for (const sessionFile of sessionFiles) {
        try {
          const sessionId = basename(sessionFile, '.jsonl')

          // Get file stats for created_at
          const stats = await fs.stat(sessionFile)
          const created_at = Math.floor((stats.birthtimeMs || stats.ctimeMs) / 1000)

          // Extract first user message and timestamp
          const { firstMessage, messageTimestamp } = await extractFirstUserMessage(sessionFile)

          // Try to load associated todo data
          const todoPath = join(todosDir, `${sessionId}.json`)
          let todo_data = null
          try {
            if (await exists(todoPath)) {
              const todoContent = await fs.readFile(todoPath, 'utf-8')
              todo_data = JSON.parse(todoContent)
            }
          } catch {
            // Todo file doesn't exist or is invalid
          }

          sessions.push({
            id: sessionId,
            project_id: projectId,
            project_path: actualProjectPath,
            todo_data,
            created_at,
            first_message: firstMessage,
            message_timestamp: messageTimestamp
          })
        } catch (error) {
          console.error('Error processing session file:', sessionFile, error)
          // Skip invalid session files
        }
      }

      // Sort sessions by creation time (newest first)
      return sessions.sort((a, b) => b.created_at - a.created_at)
    } catch (error) {
      console.error('Error getting project sessions:', error)
      return []
    }
  })

  // Claude Settings - Only return ~/.claude/settings.json content
  ipcMain.handle('get-claude-settings', async () => {
    console.log('Main: get-claude-settings called')
    try {
      const claudeSettingsPath = join(homedir(), '.claude/settings.json')
      try {
        const claudeSettingsContent = await fs.readFile(claudeSettingsPath, 'utf-8')
        return JSON.parse(claudeSettingsContent)
      } catch {
        // Return empty object if file doesn't exist or is invalid
        return {}
      }
    } catch (error) {
      console.error('Error getting Claude settings:', error)
      return {}
    }
  })

  ipcMain.handle('save-claude-settings', async (_, settings: any) => {
    console.log('Main: save-claude-settings called with', settings)
    try {
      // Only save to ~/.claude/settings.json
      const claudeDir = join(homedir(), '.claude')
      const claudeSettingsPath = join(claudeDir, 'settings.json')

      await fs.mkdir(claudeDir, { recursive: true })
      await fs.writeFile(claudeSettingsPath, JSON.stringify(settings, null, 2))

      return 'Settings saved successfully'
    } catch (error) {
      console.error('Error saving Claude settings:', error)
      throw new Error('Failed to save settings')
    }
  })

  // Version Check
  ipcMain.handle('check-claude-version', async () => {
    console.log('Main: check-claude-version called')
    try {
      return await claudeBinaryManager.checkClaudeVersion()
    } catch (error) {
      console.error('Error checking Claude version:', error)
      return {
        is_installed: false,
        output: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  })

  // Claude Code Execution
  ipcMain.handle('execute-claude-code', async (_, { projectPath, message, model }) => {
    console.log('Main: execute-claude-code called with', { projectPath, message, model })
    try {
      const binaryPath = await claudeBinaryManager.findClaudeBinary()

      const args: string[] = []
      if (message) {
        args.push('-p', message)
      }
      if (model) {
        args.push('--model', model)
      }
      args.push('--output-format', 'stream-json')
      args.push('--verbose')
      args.push('--dangerously-skip-permissions')

      // Register the process with the process manager
      const runId = await processManager.registerAgentProcess(
        0, // Not an agent run, use 0
        'Claude Code Session',
        projectPath,
        message || 'Interactive session',
        model || 'default',
        binaryPath,
        args,
        { cwd: projectPath }
      )

      return { success: true, runId, message: 'Claude Code session started' }
    } catch (error) {
      console.error('Error executing Claude Code:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  })

  ipcMain.handle('continue-claude-code', async (_, { projectPath, message, model }) => {
    console.log('Main: continue-claude-code called with', { projectPath, message, model })
    try {
      const binaryPath = await claudeBinaryManager.findClaudeBinary()

      const args: string[] = ['-c'] // Continue flag
      if (message) {
        args.push('-p', message)
      }
      if (model) {
        args.push('--model', model)
      }
      args.push('--output-format', 'stream-json')
      args.push('--verbose')
      args.push('--dangerously-skip-permissions')

      const runId = await processManager.registerAgentProcess(
        0,
        'Claude Code Continuation',
        projectPath,
        message || 'Continue session',
        'default',
        binaryPath,
        args,
        { cwd: projectPath }
      )

      return { success: true, runId, message: 'Claude Code continuation started' }
    } catch (error) {
      console.error('Error continuing Claude Code:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  })

  ipcMain.handle('resume-claude-code', async (_, { projectPath, sessionId, prompt, model }) => {
    console.log('Main: resume-claude-code called with', { projectPath, sessionId, prompt, model })
    try {
      const binaryPath = await claudeBinaryManager.findClaudeBinary()

      const args: string[] = ['--resume', sessionId]
      if (prompt) {
        args.push('-p', prompt)
      }
      if (model) {
        args.push('--model', model)
      }
      args.push('--output-format', 'stream-json')
      args.push('--verbose')
      args.push('--dangerously-skip-permissions')

      // Register the process with the process manager
      const runId = await processManager.registerAgentProcess(
        0, // Not an agent run, use 0
        'Claude Code Resume',
        projectPath,
        prompt || 'Resume session',
        model || 'default',
        binaryPath,
        args,
        { cwd: projectPath }
      )

      return { success: true, runId, message: 'Claude Code session resumed' }
    } catch (error) {
      console.error('Error resuming Claude Code:', error)
      return {
        success: false,
        runId: undefined,
        message: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  })

  ipcMain.handle('cancel-claude-execution', async (_, runId: number) => {
    console.log('Main: cancel-claude-execution called with', runId)
    try {
      const success = await processManager.killProcess(runId)
      return {
        success,
        message: success ? 'Process cancelled successfully' : 'Failed to cancel process'
      }
    } catch (error) {
      console.error('Error cancelling Claude execution:', error)
      return {
        success: false,
        message: error instanceof Error ? error.message : 'Unknown error'
      }
    }
  })

  // File Operations
  ipcMain.handle('read-claude-md-file', async (_, filePath: string) => {
    console.log('Main: read-claude-md-file called with', filePath)
    try {
      const content = await fs.readFile(filePath, 'utf-8')
      return content
    } catch (error) {
      console.error('Error reading file:', error)
      throw new Error('Failed to read file')
    }
  })

  ipcMain.handle('save-claude-md-file', async (_, { filePath, content }) => {
    console.log('Main: save-claude-md-file called with', { filePath, content })
    try {
      // Ensure directory exists
      await fs.mkdir(dirname(filePath), { recursive: true })
      await fs.writeFile(filePath, content, 'utf-8')
      return 'File saved successfully'
    } catch (error) {
      console.error('Error saving file:', error)
      throw new Error('Failed to save file')
    }
  })

  ipcMain.handle('find-claude-md-files', async (_, projectPath: string) => {
    console.log('Main: find-claude-md-files called with', projectPath)
    try {
      const pattern = join(projectPath, '**/CLAUDE.md')
      const files = await glob(pattern.replace(/\\/g, '/'))

      // Get file stats for each file
      const filesWithStats = await Promise.all(
        files.map(async (filePath) => {
          try {
            const stats = await fs.stat(filePath)
            const relativePath = filePath.replace(projectPath, '').replace(/^[/\\]/, '')

            return {
              relative_path: relativePath,
              absolute_path: filePath,
              size: stats.size,
              modified: Math.floor((stats.mtimeMs || stats.ctimeMs) / 1000) // Convert to Unix timestamp in seconds
            }
          } catch (error) {
            console.error('Error getting stats for file:', filePath, error)
            return null
          }
        })
      )

      // Filter out failed files
      return filesWithStats.filter((file) => file !== null)
    } catch (error) {
      console.error('Error finding CLAUDE.md files:', error)
      return []
    }
  })

  // File Dialogs
  ipcMain.handle('show-open-dialog', async (_, options) => {
    const result = await dialog.showOpenDialog(options)
    if (result.canceled) {
      return null
    }

    // For directory selection (which is typical for project paths), return single path
    // To match Tauri's behavior where open() returns a string for single selection
    if (options.properties && options.properties.includes('openDirectory')) {
      return result.filePaths[0] || null
    }

    // For file selection, return array if multiple, string if single
    return options.properties && options.properties.includes('multiSelections')
      ? result.filePaths
      : result.filePaths[0] || null
  })

  ipcMain.handle('show-save-dialog', async (_, options) => {
    const result = await dialog.showSaveDialog(options)
    return result.canceled ? null : result.filePath
  })

  // System Prompt Management
  ipcMain.handle('get-system-prompt', async () => {
    console.log('Main: get-system-prompt called')
    try {
      const claudeDir = join(homedir(), '.claude')
      const systemPromptPath = join(claudeDir, 'CLAUDE.md')

      try {
        const content = await fs.readFile(systemPromptPath, 'utf-8')
        return content
      } catch {
        // Return default system prompt if file doesn't exist
        return '# Claude System Prompt\n\nAdd your global system prompt here.'
      }
    } catch (error) {
      console.error('Error getting system prompt:', error)
      throw new Error('Failed to get system prompt')
    }
  })

  ipcMain.handle('save-system-prompt', async (_, { content }) => {
    console.log('Main: save-system-prompt called')
    try {
      const claudeDir = join(homedir(), '.claude')
      const systemPromptPath = join(claudeDir, 'CLAUDE.md')

      // Ensure directory exists
      await fs.mkdir(claudeDir, { recursive: true })
      await fs.writeFile(systemPromptPath, content, 'utf-8')
      return 'System prompt saved successfully'
    } catch (error) {
      console.error('Error saving system prompt:', error)
      throw new Error('Failed to save system prompt')
    }
  })

  // Claude Binary Management
  ipcMain.handle('get-claude-binary-path', async () => {
    console.log('Main: get-claude-binary-path called')
    try {
      const setting = await appSettingsService.getSetting('claude_binary_path')
      return setting || null
    } catch (error) {
      console.error('Error getting Claude binary path:', error)
      return null
    }
  })

  ipcMain.handle('set-claude-binary-path', async (_, { path }) => {
    console.log('Main: set-claude-binary-path called with', path)
    try {
      await appSettingsService.setSetting('claude_binary_path', path)
      return 'Claude binary path saved successfully'
    } catch (error) {
      console.error('Error setting Claude binary path:', error)
      throw new Error('Failed to set Claude binary path')
    }
  })

  ipcMain.handle('list-claude-installations', async () => {
    console.log('Main: list-claude-installations called')
    try {
      return await claudeBinaryManager.listClaudeInstallations()
    } catch (error) {
      console.error('Error listing Claude installations:', error)
      return []
    }
  })

  // Running Sessions Management
  ipcMain.handle('list-running-claude-sessions', async () => {
    console.log('Main: list-running-claude-sessions called')
    try {
      return processManager.getRunningClaudeSessions()
    } catch (error) {
      console.error('Error listing running Claude sessions:', error)
      return []
    }
  })

  // Update session ID for a running process
  ipcMain.handle('update-session-id', async (_, { runId, sessionId }) => {
    console.log('Main: update-session-id called with', { runId, sessionId })
    processManager.updateSessionId(runId, sessionId)
    return { success: true }
  })

  ipcMain.handle('list-running-sessions', async () => {
    console.log('Main: list-running-sessions called')
    try {
      return processManager.getRunningProcesses()
    } catch (error) {
      console.error('Error listing running sessions:', error)
      return []
    }
  })

  // New Smart Detection System APIs
  ipcMain.handle('get-detection-stats', async () => {
    console.log('Main: get-detection-stats called')
    try {
      return await claudeBinaryManager.getDetectionStats()
    } catch (error) {
      console.error('Error getting detection stats:', error)
      return {
        isDetected: false,
        platform: process.platform,
        executionMethod: process.platform === 'win32' ? 'wsl' : 'native'
      }
    }
  })

  ipcMain.handle('redetect-claude', async () => {
    console.log('Main: redetect-claude called')
    try {
      return await claudeBinaryManager.redetectClaude()
    } catch (error) {
      console.error('Error redetecting Claude:', error)
      return {
        success: false,
        platform: process.platform,
        executionMethod: process.platform === 'win32' ? 'wsl' : 'native',
        error: {
          type: 'DETECTION_FAILED',
          message: error instanceof Error ? error.message : 'Redetection failed'
        }
      }
    }
  })

  ipcMain.handle('get-last-detection-result', async () => {
    console.log('Main: get-last-detection-result called')
    try {
      return claudeBinaryManager.getLastDetectionResult()
    } catch (error) {
      console.error('Error getting last detection result:', error)
      return null
    }
  })

  // Session History
  ipcMain.handle('load-session-history', async (_, { sessionId, projectId }) => {
    console.log('Main: load-session-history called with', { sessionId, projectId })
    try {
      const claudeProjectsDir = join(homedir(), '.claude/projects')
      const sessionPath = join(claudeProjectsDir, projectId, `${sessionId}.jsonl`)

      console.log('Main: load-session-history - Looking for session file at:', sessionPath)
      console.log('Main: load-session-history - Claude projects directory:', claudeProjectsDir)
      console.log('Main: load-session-history - Project directory:', join(claudeProjectsDir, projectId))

      // Check if file exists
      if (!(await exists(sessionPath))) {
        console.log('Main: load-session-history - Session file does not exist at expected path')

        // Let's also check what files actually exist in the project directory
        try {
          const projectDir = join(claudeProjectsDir, projectId)
          const projectDirExists = await exists(projectDir)
          console.log('Main: load-session-history - Project directory exists:', projectDirExists)

          if (projectDirExists) {
            const files = await fs.readdir(projectDir)
            console.log('Main: load-session-history - Files in project directory:', files)
          }

          // Also check what project directories exist
          const claudeDirExists = await exists(claudeProjectsDir)
          console.log('Main: load-session-history - Claude projects directory exists:', claudeDirExists)

          if (claudeDirExists) {
            const projectDirs = await fs.readdir(claudeProjectsDir)
            console.log('Main: load-session-history - Available project directories:', projectDirs)
          }
        } catch (debugError) {
          console.log('Main: load-session-history - Error during debug logging:', debugError)
        }

        throw new Error(`Session file not found: ${sessionId}`)
      }

      console.log('Main: load-session-history - Session file found, reading content')
      const content = await fs.readFile(sessionPath, 'utf-8')
      const lines = content.split('\n').filter((line) => line.trim())
      const messages: any[] = []

      for (const line of lines) {
        try {
          const json = JSON.parse(line)
          messages.push(json)
        } catch {
          // Skip invalid JSON lines
        }
      }

      console.log('Main: load-session-history - Successfully loaded', messages.length, 'messages')
      return messages
    } catch (error) {
      console.error('Error loading session history:', error)
      throw error
    }
  })

  // File System Operations
  ipcMain.handle('list-directory-contents', async (_, { directoryPath }) => {
    console.log('Main: list-directory-contents called with', directoryPath)
    try {
      const entries = await fs.readdir(directoryPath, { withFileTypes: true })
      const contents = entries.map((entry) => ({
        name: entry.name,
        path: join(directoryPath, entry.name),
        isDirectory: entry.isDirectory(),
        isFile: entry.isFile()
      }))
      return contents
    } catch (error) {
      console.error('Error listing directory contents:', error)
      throw new Error(
        `Failed to list directory: ${error instanceof Error ? error.message : 'Unknown error'}`
      )
    }
  })

  ipcMain.handle('search-files', async (_, { basePath, query }) => {
    console.log('Main: search-files called with', { basePath, query })
    try {
      // Use glob to search for files matching the query pattern
      const pattern = join(basePath, '**', `*${query}*`)
      const files = await glob(pattern.replace(/\\/g, '/'), {
        nodir: false, // Include directories
        dot: false // Exclude hidden files by default
      })

      // Get file stats and organize results
      const results = await Promise.all(
        files.map(async (filePath) => {
          try {
            const stats = await fs.stat(filePath)
            const relativePath = filePath.replace(basePath, '').replace(/^[/\\]/, '')

            return {
              name: basename(filePath),
              path: filePath,
              relativePath,
              isDirectory: stats.isDirectory(),
              isFile: stats.isFile(),
              size: stats.size,
              modified: Math.floor(stats.mtimeMs / 1000)
            }
          } catch (error) {
            console.error('Error getting stats for file:', filePath, error)
            return null
          }
        })
      )

      return results.filter((result) => result !== null)
    } catch (error) {
      console.error('Error searching files:', error)
      throw new Error(
        `Failed to search files: ${error instanceof Error ? error.message : 'Unknown error'}`
      )
    }
  })

  // Checkpoint Manager
  ipcMain.handle('clear-checkpoint-manager', async (_, sessionId: string) => {
    console.log('Main: clear-checkpoint-manager called with', sessionId)
    try {
      // For Claude Code sessions, we don't maintain separate checkpoint state
      // The checkpoints are managed by Claude Code itself through JSONL files
      // This is a no-op for now, but we could add session cleanup logic here

      console.log(`Checkpoint manager cleared for session: ${sessionId}`)
      return { success: true, message: 'Checkpoint manager cleared' }
    } catch (error) {
      console.error('Error clearing checkpoint manager:', error)
      throw new Error(
        `Failed to clear checkpoint manager: ${error instanceof Error ? error.message : 'Unknown error'}`
      )
    }
  })

  // Window Controls are handled by @electron-toolkit/utils registerFramelessWindowIpc()
}
